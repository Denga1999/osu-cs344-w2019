#!/bin/bash
#
# matrix
#
# Phi Luu
#
# Oregon State University
# CS 344_001_W2019 Operating Systems 1
# Program 1: Matrices

# Validates a matrix by making sure all rows have the same number of elements
# and all elements are integers.
#
# SYNOPSIS
#   is_int_matrix MATRIX
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows (to be validated)
#
# RETURNS
#   0 - if the  matrix  argument is a valid matrix
#   1 - otherwise
is_int_matrix() {
  # ensure there is a non-empty and valid filename to check
  if [[ "$#" -ne 1 ]] || [[ -z "$1" ]] || [[ ! -f "$1" ]]; then
    return 1
  fi

  # count the number of rows
  local num_rows="$(wc -l < "$1")"
  # count the number of elements
  local num_elems="$(wc -w < "$1")"

  # #elements must be divisible by #rows
  if [[ "$(expr ${num_elems} % ${num_rows})" -ne 0 ]]; then
    return 1
  fi

  # TODO: Check integers

  return 0
}

# Rounds the result of integer division to the nearest integer, away from 0.
# Source: OSU CS 344 Canvas
#
# SYNOPSIS
#   round_div DIVIDEND DIVISOR
#
# ARGUMENTS
#   DIVIDEND - the integer number to be divided up
#   DIVISOR - the integer by which the  DIVIDEND  is to be divided
#
# RETURNS
#   The rounded result to the nearest integer and away from 0.
round_div() {
  if [[ "$#" -ne 2 ]] || [[ -z "$1" ]] || [[ -z "$2" ]]; then
    return 1
  fi

  _RET=$((($1 + ($2 / 2) * ( ($1 > 0) * 2 - 1 )) / $2))
}

# Prints the dimensions of the matrix as the number of rows, followed by a
# space, then the number of columns.
#
# SYNOPSIS
#   dims [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
dims() {
  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix dims [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]] && [[ ! -f "$1" ]]; then
    echo 'Could not read file' >&2
    return 1
  fi

  if ! is_int_matrix "$1"; then
    echo 'Invalid matrix' >&2
    return 1
  fi

  # count the number of rows
  local num_rows="$(wc -l < "$1")"
  # count the number of columns = num of elements / num of rows
  local num_cols="$(expr $(wc -w < "$1") / ${num_rows})"

  printf "%d %d" ${num_rows} ${num_cols}
}

# Prints a matrix reflected along the main diagonal. In other words, prints the
# matrix from left to right, column first. An M-by-N matrix will be transposed
# to an N-by-M matrix.
#
# SYNOPSIS
#   transpose [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
transpose() {
  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix transpose [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]] && [[ ! -f "$1" ]]; then
    echo 'Could not read file' >&2
    return 1
  fi

  if ! is_int_matrix "$1"; then
    echo 'Invalid matrix' >&2
    return 1
  fi

  # get the number of columns
  local num_cols="$(expr $(wc -w < "$1") / $(wc -l < "$1"))"
 
  # read each column and output it horizontally
  for ((i=1;i<=num_cols;i++)); do
    printf "%s\n" "$(cut -f ${i} "$1" | column)"
  done
}

# Takes in an M-by-N matrix and prints a 1-by-N row vector whose each element
# is the mean of the matrix's column containing that elements.
#
# SYNOPSIS
#   mean [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
mean() {
  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix mean [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]] && [[ ! -f "$1" ]]; then
    echo 'Could not read file' >& 2
    return 1
  fi

  if ! is_int_matrix "$1"; then
    echo 'Invalid matrix' >&2
    return 1
  fi

  # get the number of rows
  local num_rows="$(wc -l < "$1")"
  # get the number of columns
  local num_cols="$(expr $(wc -w < "$1") / ${num_rows})"

  # read each column
  for ((i=1;i<=num_cols;i++)); do
    local col="$(cut -f ${i} "$1" | column)"
   
    # get the mean of the current column
    local sum=0
    for elem in ${col}; do
      sum="$(expr ${sum} + ${elem})"
    done
    round_div ${sum} ${num_rows}
    local avg=${_RET}

    # print result with correct format
    printf "%d" ${avg}
    if [[ "${i}" -lt "${num_cols}" ]]; then
      printf "\t"
    else
      printf "\n"
    fi
  done
}

# TODO: validate command line arguments and use  $1 "${@:2}"  instead of using case
case "$1" in
  'dims')
    dims "${@:2}"
    ;;
  'transpose')
    transpose "${@:2}"
    ;;
  'mean')
    mean "${@:2}"
    ;;
  *)
    echo 'Invalid argument. Usage:' >&2
    echo './matrix dims [MATRIX]' >&2
    echo './matrix transpose [MATRIX]' >&2
    echo './matrix mean [MATRIX]' >&2
    echo './matrix add MATRIX_LEFT MATRIX_RIGHT' >&2
    echo './matrix multiply MATRIX_LEFT MATRIX_RIGHT' >&2
esac
