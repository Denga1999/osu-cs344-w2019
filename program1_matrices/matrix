#!/bin/bash
#
# matrix
#
# Phi Luu
#
# Oregon State University
# CS 344_001_W2019 Operating Systems 1
# Program 1: Matrices

# Validates a matrix by making sure all rows have the same number of elements
# and all elements are integers.
#
# SYNOPSIS
#   is_int_matrix MATRIX
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows (to be validated)
#
# RETURNS
#   0 - if the  matrix  argument is a valid matrix
#   1 - otherwise
is_int_matrix() {
  # ensure there is a non-empty and valid filename to check
  if [[ "$#" -ne 1 ]] || [[ -z "$1" ]] || [[ ! -f "$1" ]]; then
    echo 'Could not read files and/or arguments' >&2
    return 1
  fi

  # read the row in raw format
  # Credits: https://stackoverflow.com/a/29689199
  # https://stackoverflow.com/q/17542892
  while IFS= read -r row; do
    # invalid if there is any character other than digits, neg signs, tabs, and
    # newlines
    if [[ "${row}" =~ [^\t\d\-\n] ]]; then
      echo 'Invalid matrix (non-digit/negative sign/tab/newline detected)' >&2
      return 1
    fi
    # invalid if 2 or more consecutive neg signs or tabs
    if [[ "${rows}" =~ [\-]{2,} ]] || [[ "${row}" =~ [\t]{2,} ]]; then
      echo 'Invalid matrix (two or more tabs/negative signs detected)' >&2
      return 1
    fi
    # invalid if the raw row ends or starts with a non-digit
    if [[ "${row}" =~ [^\d]$ ]] || [[ "${row}" =~ ^[^\d] ]]; then
      echo 'Invalid matrix (trailing/leading with a non-digit)' >&2
      return 1
    fi
  done < "$1"

  # ensure all rows have the same number of elements as the header row
  local header="$(head -n 1 "$1")"
  header=(${header})
  local num_cols=${#header[@]}
  while read row; do
    row=(${row})
    if [[ ${#row[@]} -ne ${num_cols} ]]; then
      echo 'Invalid matrix (not rectangular)' >&2
      return 1
    fi
  done < "$1"

  return 0
}

# Rounds the result of integer division to the nearest integer, away from 0.
# Source: OSU CS 344 Canvas
#
# SYNOPSIS
#   round_div DIVIDEND DIVISOR
#
# ARGUMENTS
#   DIVIDEND - the integer number to be divided up
#   DIVISOR - the integer by which the  DIVIDEND  is to be divided
#
# RETURNS
#   The rounded result to the nearest integer and away from 0.
round_div() {
  if [[ "$#" -ne 2 ]] || [[ -z "$1" ]] || [[ -z "$2" ]]; then
    return 1
  fi

  _RET=$((($1 + ($2 / 2) * ( ($1 > 0) * 2 - 1 )) / $2))
}

# Prints the dimensions of the matrix as the number of rows, followed by a
# space, then the number of columns.
#
# SYNOPSIS
#   dims [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
dims() {
  local fin="fin$$"

  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix dims [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]]; then
    if [[ ! -f "$1" ]]; then
      echo 'Could not read file' >&2
      return 1
    else
      fin="$1"
    fi
  # if using stdin, cat to temporary file
  else
    cat > "${fin}"
  fi

  if ! is_int_matrix "${fin}"; then
    return 1
  fi

  # count the number of rows
  local num_rows="$(wc -l < "${fin}")"
  # count the number of columns = num of elements / num of rows
  local num_cols="$(expr $(wc -w < "${fin}") / ${num_rows})"

  printf "%d %d\n" ${num_rows} ${num_cols}
}

# Prints a matrix reflected along the main diagonal. In other words, prints the
# matrix from left to right, column first. An M-by-N matrix will be transposed
# to an N-by-M matrix.
#
# SYNOPSIS
#   transpose [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
transpose() {
  local fin="fin$$"

  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix transpose [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]]; then
    if [[ ! -f "$1" ]]; then
      echo 'Could not read file' >&2
      return 1
    else
      fin="$1"
    fi
  # if using stdin, use temporary file
  else
    cat > "${fin}"
  fi

  if ! is_int_matrix "${fin}"; then
    return 1
  fi

  # get the number of columns
  local num_cols="$(expr $(wc -w < "${fin}") / $(wc -l < "${fin}"))"

  # read each column and output it horizontally
  for ((i=1;i<=num_cols;i++)); do
    printf "%s\n" "$(cut -f ${i} "${fin}" | column)"
  done
}

# Takes in an M-by-N matrix and prints a 1-by-N row vector whose each element
# is the mean of the matrix's column containing that elements.
#
# SYNOPSIS
#   mean [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
mean() {
  local fin="fin$$"

  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix mean [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]]; then
    if [[ ! -f "$1" ]]; then
      echo 'Could not read file' >& 2
      return 1
    else
      fin="$1"
    fi
  else
    cat > "${fin}"
  fi

  if ! is_int_matrix "${fin}"; then
    return 1
  fi

  # get the number of rows
  local num_rows="$(wc -l < "${fin}")"
  # get the number of columns
  local num_cols="$(expr $(wc -w < "${fin}") / ${num_rows})"

  # read each column
  for ((i=1;i<=num_cols;i++)); do
    local col="$(cut -f ${i} "${fin}" | column)"

    # get the mean of the current column
    local sum=0
    for elem in ${col}; do
      sum="$(expr ${sum} + ${elem})"
    done
    round_div ${sum} ${num_rows}
    local avg=${_RET}

    # print result with correct format
    printf "%d" ${avg}
    if [[ "${i}" -lt "${num_cols}" ]]; then
      printf "\t"
    else
      printf "\n"
    fi
  done
}

trap "rm -f fin$$" INT HUP TERM

# TODO: validate command line arguments and use  $1 "${@:2}"  instead of using case
case "$1" in
  'dims')
    dims "${@:2}"
    ;;
  'transpose')
    transpose "${@:2}"
    ;;
  'mean')
    mean "${@:2}"
    ;;
  *)
    echo 'Invalid argument. Usage:' >&2
    echo './matrix dims [MATRIX]' >&2
    echo './matrix transpose [MATRIX]' >&2
    echo './matrix mean [MATRIX]' >&2
    echo './matrix add MATRIX_LEFT MATRIX_RIGHT' >&2
    echo './matrix multiply MATRIX_LEFT MATRIX_RIGHT' >&2
esac

# clean up
rm -f "fin$$"
