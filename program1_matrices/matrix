#!/bin/bash
#
# matrix
#
# Phi Luu
#
# Oregon State University
# CS_344_001_W2019 Operating Systems 1
# Program 1: Matrices

# Rounds the result of integer division to the nearest integer, away from 0.
# Source: OSU CS 344 Canvas
#
# SYNOPSIS
#   round_div DIVIDEND DIVISOR
#
# ARGUMENTS
#   DIVIDEND - the integer number to be divided up
#   DIVISOR - the integer by which the  DIVIDEND  is to be divided
#
# RETURNS
#   The rounded result to the nearest integer and away from 0.
round_div() {
  if [[ "$#" -ne 2 ]] || [[ -z "$1" ]] || [[ -z "$2" ]]; then
    return 1
  fi

  # formula provided by Brewster
  _RET="$((($1 + ($2 / 2) * (2 * ($1 > 0) - 1 )) / $2))"
}

# Prints the dimensions of the matrix as the number of rows, followed by a
# space, then the number of columns.
#
# SYNOPSIS
#   dims [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
dims() {
  local fin="fin$$"

  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix dims [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]]; then
    if [[ ! -f "$1" ]]; then
      echo 'Could not read file' >&2
      return 1
    else
      fin="$1"
    fi
  # if using stdin, cat to temporary file
  else
    cat > "${fin}"
  fi

  # read the first row of matrix as an array
  read -a header < "${fin}"

  # count the number of rows
  local num_rows="$(wc -l < "${fin}")"
  # count the number of columns = num of elements in the header row
  local num_cols="${#header[@]}"

  printf "%d %d\n" "${num_rows}" "${num_cols}"
}

# Prints a matrix reflected along the main diagonal. In other words, prints the
# matrix from left to right, column first. An M-by-N matrix will be transposed
# to an N-by-M matrix.
#
# SYNOPSIS
#   transpose [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
transpose() {
  local fin="fin$$"

  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix transpose [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]]; then
    if [[ ! -f "$1" ]]; then
      echo 'Could not read file' >&2
      return 1
    else
      fin="$1"
    fi
  # if using stdin, use temporary file
  else
    cat > "${fin}"
  fi

  # get the number of columns
  read -a header < "${fin}"
  local num_cols="${#header[@]}"

  # loop through the columns and transpose each of them
  for ((i=1;i<=num_cols;i++)); do
    printf "%s\n" "$(cut -f "${i}" "${fin}" | column)"
  done
}

# Takes in an M-by-N matrix and prints a 1-by-N row vector whose each element
# is the mean of the matrix's column containing that elements.
#
# SYNOPSIS
#   mean [MATRIX]
#
# ARGUMENTS
#   MATRIX - a string of EOL-separated rows, each contains an equal number of
#  tab-separated integers.
#
# RETURNS
#   None
mean() {
  local fin="fin$$"

  # ensure there is at most 1 argument
  if [[ "$#" -gt 1 ]]; then
    echo 'Usage: ./matrix mean [MATRIX]' >&2
    return 1
  # if using file, ensure the file exists
  elif [[ "$#" -eq 1 ]]; then
    if [[ ! -f "$1" ]]; then
      echo 'Could not read file' >& 2
      return 1
    else
      fin="$1"
    fi
  else
    cat > "${fin}"
  fi

  # use the dims() function to get dimensions of the matrix
  local dimensions=($(dims "${fin}"))
  local num_rows="${dimensions[0]}"
  local num_cols="${dimensions[1]}"

  # read each column
  for ((i=1;i<=num_cols;i++)); do
    local col="$(cut -f "${i}" "${fin}" | column)"

    # get the mean of the current column
    local sum=0
    for num in ${col}; do
      ((sum+=num))
    done
    round_div "${sum}" "${num_rows}"
    local avg="${_RET}"

    # print result with correct format
    printf "%d" "${avg}"
    if [[ "${i}" -lt "${num_cols}" ]]; then
      printf "\t"
    else
      printf "\n"
    fi
  done
}

# Takes in 2 M-by-N matrices and prints a M-by-N matrix formed by adding the two
# input matrices
#
# SYNOPSIS
#   add MATRIX_LEFT MATRIX_RIGHT
#
# ARGUMENTS
#   MATRIX_LEFT - a string of EOL-separated rows, each contains an equal number
#  of tab-separated integers.
#   MATRIX_RIGHT - a string of EOL-separated rows, each contains an equal number
#  of tab-separated integers
#
# NOTES
#   Assume  MATRIX_LEFT  and  MATRIX_RIGHT  have the same number of rows and
#  the same number of columns.
#
# RETURNS
#   None
add() {
  # ensure there are exactly 2 arguments
  if [[ "$#" -ne 2 ]]; then
    echo 'Usage: ./matrix add MATRIX_LEFT MATRIX_RIGHT' >&2
    return 1
  # ensure the files exist
  elif [[ ! -f "$1" ]] || [[ ! -f "$2" ]]; then
    echo 'Could not read file(s)' >&2
    return 1
  # ensure both matrices have the same dimensions
  elif [[ "$(dims "$1")" != "$(dims "$2")" ]]; then
    echo 'Invalid matrix summation' >&2
    return 1
  fi

  declare -A matleft
  declare -A matright
  local dimensions=($(dims "$1"))
  local num_rows="${dimensions[0]}"
  local num_cols="${dimensions[1]}"

  # read the left-hand-side matrix
  local i=0
  while read row; do
    # echo "Row is: ${row}"
    row=(${row})
    for ((j=0;j<num_cols;j++)); do
      matleft["${i}","${j}"]="${row["${j}"]}"
    done
    ((i++))
  done < "$1"

  # read the right-hand-side matrix
  i=0
  while read row; do
    row=(${row})
    for ((j=0;j<num_cols;j++)); do
      matright["${i}","${j}"]="${row["${j}"]}"
    done
    ((i++))
  done < "$2"

  # add two matrices and print results
  for ((i=0;i<num_rows;i++)); do
    for ((j=0;j<num_cols;j++)); do
      local left="${matleft["${i}","${j}"]}"
      local right="${matright["${i}","${j}"]}"

      printf "%d" "$(expr "${left}" + "${right}")"

      if [[ "${j}" -lt "$(expr "${num_cols}" - 1)" ]]; then
        printf "\t"
      fi
    done
    printf "\n"
  done
}

trap "rm -f fin$$" INT HUP TERM

# TODO: validate command line arguments and use  $1 "${@:2}"  instead of using case
case "$1" in
  'dims')
    dims "${@:2}"
    ;;
  'transpose')
    transpose "${@:2}"
    ;;
  'mean')
    mean "${@:2}"
    ;;
  'add')
    add "${@:2}"
    ;;
  *)
    echo 'Invalid argument. Usage:' >&2
    echo './matrix dims [MATRIX]' >&2
    echo './matrix transpose [MATRIX]' >&2
    echo './matrix mean [MATRIX]' >&2
    echo './matrix add MATRIX_LEFT MATRIX_RIGHT' >&2
    echo './matrix multiply MATRIX_LEFT MATRIX_RIGHT' >&2
esac

# clean up
rm -f "fin$$"
